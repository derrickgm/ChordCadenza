<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>This should contain at least a chord file (*.chp) and an audio file ( *.mp1, *.mp2, *.mp3, *.wav, *.riff, *.aiff, .or *.ogg).

The audio file should be an approximate match to the chord file. This means it should have the same rhythm and structure, but doesn't need to be in the same key.


</value>
  </data>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>Go to^PlayMap Menu &gt; Configure &gt; Miscellaneous$ 

The checkbox^Sync Audio Play Sync$in the^General$panel controls whether the play position will be visibly updated just before entering new sync data.

Set this on if you are not sure whether you can identify the cue point when the audio file plays.

Set it off if you find the cursor update distracting whilst recording new sync data. </value>
  </data>
  <data name="richTextBox2.Text" xml:space="preserve">
    <value>You can use the^TrackMap$or^ChordMap$to do this. However, you will need to cue to somewhere you will recognise in the song (e.g. when a solo or vocal starts) that is on a barline.

If you have created a lyric file (*.chl), you can use the^TrackMap$or^ChordMap$to show the lyrics, and use them to help find a good cue point.

Otherwise, it's usually easier to use a solo track on the^TrackMap$to find a cue point.

***Set the normal cursor in the^TrackMap$(click in any track pane) or^ChordMap$(click in body of^Midi$pane) to wherever you want the song to start playing (usually at the start).

***Click inside the Bar pane in the^TrackMap$or^ChordMap$to set the cue position - the bar will be highlighted in sky blue. This must be after the start point. 
</value>
  </data>
  <data name="richTextBox4.Text" xml:space="preserve">
    <value>Click the^Sync Audio$button on any playable window (^TrackMap, ChordMap or PlayMap$) to start playing the audiofile. Hit the^Sync$SwitchKey (or Pedal) when the cue point is reached. 

The^Sync Audio$button on the^PlayMap$should turn red. Continue to hit the key on every beat until the end.

Hit the^Stop Play$button to end the sync.

If you don't get to the end, you can start again from the same or a different cue point and start point.

The sync data will be saved in the^AudioSync Record Track.$ The^Play Track$will not be updated until you use^Copy$or^Merge$from the^AutoSync$window.</value>
  </data>
  <data name="richTextBox5.Text" xml:space="preserve">
    <value>The^AudioSync Record Track$contains the last sync that you recorded.

If you want to save or play this, you will need to merge or copy it into the^AudioSync Play Track.$

Open the^AutoSync$window from^PlayMap Menu &gt; File &gt; Show AudioSync Window$ 

Click the^Merge Record To Play$button. If you get an error message, it means you are trying to merge data that is not in sequence. You will have to either use^Copy Record To Play$or re-record the sync data.

***You can the use the^Save Play to File$button to save the sync data to a .chtc file.</value>
  </data>
</root>